// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	domain "github.com/sonalys/letterme/domain"

	mock "github.com/stretchr/testify/mock"

	models "github.com/sonalys/letterme/account_manager/models"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

// AddNewDevice provides a mock function with given fields: ctx, accountID
func (_m *Service) AddNewDevice(ctx context.Context, accountID domain.DatabaseID) (*domain.EncryptedBuffer, error) {
	ret := _m.Called(ctx, accountID)

	var r0 *domain.EncryptedBuffer
	if rf, ok := ret.Get(0).(func(context.Context, domain.DatabaseID) *domain.EncryptedBuffer); ok {
		r0 = rf(ctx, accountID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.EncryptedBuffer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.DatabaseID) error); ok {
		r1 = rf(ctx, accountID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Authenticate provides a mock function with given fields: ctx, Address
func (_m *Service) Authenticate(ctx context.Context, Address domain.Address) (*domain.EncryptedBuffer, error) {
	ret := _m.Called(ctx, Address)

	var r0 *domain.EncryptedBuffer
	if rf, ok := ret.Get(0).(func(context.Context, domain.Address) *domain.EncryptedBuffer); ok {
		r0 = rf(ctx, Address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.EncryptedBuffer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.Address) error); ok {
		r1 = rf(ctx, Address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAccount provides a mock function with given fields: ctx, account
func (_m *Service) CreateAccount(ctx context.Context, account models.CreateAccountRequest) (domain.EncryptedBuffer, error) {
	ret := _m.Called(ctx, account)

	var r0 domain.EncryptedBuffer
	if rf, ok := ret.Get(0).(func(context.Context, models.CreateAccountRequest) domain.EncryptedBuffer); ok {
		r0 = rf(ctx, account)
	} else {
		r0 = ret.Get(0).(domain.EncryptedBuffer)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, models.CreateAccountRequest) error); ok {
		r1 = rf(ctx, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAccount provides a mock function with given fields: ctx, ownershipToken
func (_m *Service) DeleteAccount(ctx context.Context, ownershipToken domain.OwnershipKey) error {
	ret := _m.Called(ctx, ownershipToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, domain.OwnershipKey) error); ok {
		r0 = rf(ctx, ownershipToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccount provides a mock function with given fields: ctx, ownershipToken
func (_m *Service) GetAccount(ctx context.Context, ownershipToken domain.OwnershipKey) (domain.Account, error) {
	ret := _m.Called(ctx, ownershipToken)

	var r0 domain.Account
	if rf, ok := ret.Get(0).(func(context.Context, domain.OwnershipKey) domain.Account); ok {
		r0 = rf(ctx, ownershipToken)
	} else {
		r0 = ret.Get(0).(domain.Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.OwnershipKey) error); ok {
		r1 = rf(ctx, ownershipToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicKey provides a mock function with given fields: ctx, address
func (_m *Service) GetPublicKey(ctx context.Context, address domain.Address) (*domain.PublicKey, error) {
	ret := _m.Called(ctx, address)

	var r0 *domain.PublicKey
	if rf, ok := ret.Get(0).(func(context.Context, domain.Address) *domain.PublicKey); ok {
		r0 = rf(ctx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.PublicKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, domain.Address) error); ok {
		r1 = rf(ctx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetPublicKey provides a mock function with given fields: ctx, req
func (_m *Service) ResetPublicKey(ctx context.Context, req models.ResetPublicKeyRequest) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, models.ResetPublicKeyRequest) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
